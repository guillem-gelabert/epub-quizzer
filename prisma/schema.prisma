// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}


model Session {
  id          String   @id @default(uuid()) @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at")
  lastSeenAt  DateTime @default(now()) @updatedAt @map("last_seen_at")
  userAgentHash String? @map("user_agent_hash")
  locale      String?

  sessionBooks SessionBook[]
  readingProgress ReadingProgress[]
  quizzes      Quiz[]

  @@map("sessions")
}

model Book {
  id          String   @id @default(uuid()) @db.Uuid
  contentHash String   @unique @map("content_hash")
  title       String
  author      String
  toc         Json?    // Store TOC tree as JSONB
  coverPath   String?  @map("cover_path")
  createdAt   DateTime @default(now()) @map("created_at")

  sections    BookSection[]
  chunks      Chunk[]
  sessionBooks SessionBook[]
  readingProgress ReadingProgress[]
  quizzes     Quiz[]

  @@map("books")
}

model BookSection {
  id           String   @id @default(uuid()) @db.Uuid
  bookId       String   @map("book_id") @db.Uuid
  sectionIndex Int      @map("section_index")
  href         String
  title        String?
  html         String?  @db.Text // Store as text, or use htmlGzip for bytea
  htmlGzip     Bytes?   @map("html_gzip") // Optional: gzipped HTML
  plainText    String?  @map("plain_text") @db.Text // Optional: for search/faster chunking
  createdAt    DateTime @default(now()) @map("created_at")

  book         Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chunks       Chunk[]

  @@unique([bookId, sectionIndex])
  @@map("book_sections")
}

model Chunk {
  id            BigInt   @id @default(autoincrement())
  bookId        String   @map("book_id") @db.Uuid
  chunkIndex    Int      @map("chunk_index") // Global order across whole book
  sectionId     String   @map("section_id") @db.Uuid
  sectionIndex Int      @map("section_index") // Redundant but handy
  text          String   @db.Text
  wordCount     Int      @map("word_count")
  sourceHint    Json?    @map("source_hint") // Optional: element id / cfi / offsets

  book          Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  section       BookSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([bookId, chunkIndex])
  @@index([bookId, chunkIndex])
  @@map("chunks")
}

model SessionBook {
  sessionId String   @map("session_id") @db.Uuid
  bookId    String   @map("book_id") @db.Uuid
  addedAt   DateTime @default(now()) @map("added_at")

  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([sessionId, bookId])
  @@map("session_books")
}

model ReadingProgress {
  sessionId            String   @map("session_id") @db.Uuid
  bookId               String   @map("book_id") @db.Uuid
  currentChunkIndex    Int      @default(0) @map("current_chunk_index")
  unlockedUntilChunkIndex Int   @default(0) @map("unlocked_until_chunk_index")
  updatedAt             DateTime @default(now()) @updatedAt @map("updated_at")

  session              Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  book                 Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([sessionId, bookId])
  @@map("reading_progress")
}

model Quiz {
  id                  String   @id @default(uuid()) @db.Uuid
  sessionId           String   @map("session_id") @db.Uuid
  bookId              String   @map("book_id") @db.Uuid
  gateStartChunkIndex Int      @map("gate_start_chunk_index")
  gateEndChunkIndex   Int      @map("gate_end_chunk_index")
  facts               Json     // Step 1 output, store verbatim
  questions           Json     // Step 2 MCQs, store verbatim incl. correct_choice
  createdAt           DateTime @default(now()) @map("created_at")

  session             Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  book                Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  attempts            QuizAttempt[]

  @@unique([sessionId, bookId, gateStartChunkIndex, gateEndChunkIndex])
  @@map("quizzes")
}

model QuizAttempt {
  id           String   @id @default(uuid()) @db.Uuid
  quizId       String   @map("quiz_id") @db.Uuid
  answers      Json     // e.g., { "Q1":"B", "Q2":"A" }
  correctCount Int      @map("correct_count")
  passed       Boolean
  answeredAt   DateTime @default(now()) @map("answered_at")

  quiz         Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)

  @@map("quiz_attempts")
}

